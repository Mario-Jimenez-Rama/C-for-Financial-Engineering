#pragma once
#include <map>
#include <deque>
#include <vector>
#include <chrono>
#include <type_traits>
#include <cstdint>
#include "Order.hpp"
#include "OrderBook.hpp"
#include "OrderManager.hpp"

/// Simple trade record emitted by the engine.
/// You can feed these to your TradeLogger in batches.
template <typename PriceType, typename OrderIdType>
struct Trade {
    OrderIdType buy_id{};
    OrderIdType sell_id{};
    PriceType   price{};
    int         quantity{};
    std::chrono::high_resolution_clock::time_point ts{};
};

/// MatchingEngine
/// - Price/time priority using per-price FIFO queues
/// - Header-only template to match your templated Order/OMS/OrderBook setup
/// - No hard dependency on a logger; returns trades to the caller
template <typename PriceType, typename OrderIdType>
class MatchingEngine {
    static_assert(std::is_integral<OrderIdType>::value,
                  "OrderIdType must be integral");

public:
    using OrderT  = Order<PriceType, OrderIdType>;
    using TradeT  = Trade<PriceType, OrderIdType>;
    using Clock   = std::chrono::high_resolution_clock;

    MatchingEngine(OrderBook<PriceType, OrderIdType>& book,
                   OrderManager<PriceType, OrderIdType>& oms)
        : book_(book), oms_(oms) {}

    // Submit a NEW order (id must not already exist in OMS).
    // Creates in OMS, inserts into book & internal queues, then tries to match.
    // Returns all trades generated by this submission.
    std::vector<TradeT> submit(const OrderT& incoming) {
        std::vector<TradeT> trades;
        trades.reserve(8); // heuristic; reduces early reallocs

        // Create in OMS and book
        auto h = oms_.create(incoming.id, incoming.price, incoming.quantity, incoming.is_buy);
        book_.newOrder(incoming);
        id2side_[incoming.id] = incoming.is_buy;

        // Place into appropriate side queue (price-time priority)
        auto& sideBook = incoming.is_buy ? bids_ : asks_;
        auto& q = sideBook[incoming.price];  // map creates level if missing
        q.push_back(incoming.id);
        id2price_[incoming.id] = incoming.price;

        // Try to match aggressively
        auto now = Clock::now();
        if (incoming.is_buy) {
            matchBuySide(trades, now);
        } else {
            matchSellSide(trades, now);
        }
        return trades;
    }

    // Cancel an existing order by ID. Removes from queues/book/OMS.
    // Returns true if something was canceled.
    bool cancel(OrderIdType id) {
        auto itp = id2price_.find(id);
        auto its = id2side_.find(id);
        if (itp == id2price_.end() || its == id2side_.end()) return false;

        const bool is_buy = its->second;
        const PriceType px = itp->second;

        auto& sideBook = is_buy ? bids_ : asks_;
        auto lvlIt = sideBook.find(px);
        if (lvlIt == sideBook.end()) return false;

        // Remove id from the FIFO queue (linear within level, but queues are short in practice)
        auto& dq = lvlIt->second;
        for (auto it = dq.begin(); it != dq.end(); ++it) {
            if (*it == id) {
                dq.erase(it);
                if (dq.empty()) sideBook.erase(lvlIt);
                break;
            }
        }

        // Update aggregates + OMS
        const int rem = oms_.getRemainingQty(id);
        if (rem > 0) {
            // tell book we removed a live order
            // emulate delete semantics on the aggregate book
            OrderT dummy{id, PriceType{}, 0, is_buy};
            dummy.price = px;
            // reduce counts in book (using its public API)
            book_.deleteOrder(id);
        }

        bool ok = oms_.cancel(id);
        id2price_.erase(itp);
        id2side_.erase(its);
        return ok;
    }

    // Replace price on an existing order: remove from old price queue, update OMS/Book, reinsert, re-match.
    std::vector<TradeT> replacePrice(OrderIdType id, PriceType new_price) {
        std::vector<TradeT> trades;
        auto itp = id2price_.find(id);
        auto its = id2side_.find(id);
        if (itp == id2price_.end() || its == id2side_.end()) return trades;

        const bool is_buy = its->second;
        const PriceType old_px = itp->second;

        // Remove from old level queue
        auto& oldSide = is_buy ? bids_ : asks_;
        auto lvlIt = oldSide.find(old_px);
        if (lvlIt != oldSide.end()) {
            auto& dq = lvlIt->second;
            for (auto it = dq.begin(); it != dq.end(); ++it) {
                if (*it == id) {
                    dq.erase(it);
                    if (dq.empty()) oldSide.erase(lvlIt);
                    break;
                }
            }
        }

        // Update OMS and Book aggregates
        // Book: treat as delete from old price and add at new price keeping remaining qty
        const int rem = oms_.getRemainingQty(id);
        if (rem > 0) {
            book_.deleteOrder(id);
        }
        oms_.replacePrice(id, new_price);

        // Insert into new level queue and book
        OrderT shadow{id, new_price, rem, is_buy};
        book_.newOrder(shadow);

        auto& newSide = is_buy ? bids_ : asks_;
        newSide[new_price].push_back(id);
        id2price_[id] = new_price;

        // Attempt to match after reprice
        auto now = Clock::now();
        if (is_buy) matchBuySide(trades, now);
        else        matchSellSide(trades, now);

        return trades;
    }

    // Convenience: submit using an existing OMS order handle (already created)
    // Useful if you want to separate creation from book placement.
    std::vector<TradeT> addToBook(OrderIdType id) {
        std::vector<TradeT> trades;
        if (!oms_.exists(id)) return trades;
        const bool is_buy = oms_.isBuy(id);
        const PriceType px = oms_.getPrice(id);
        const int rem = oms_.getRemainingQty(id);
        if (rem <= 0) return trades;

        OrderT shadow{id, px, rem, is_buy};
        book_.newOrder(shadow);

        auto& sideBook = is_buy ? bids_ : asks_;
        sideBook[px].push_back(id);
        id2price_[id] = px;
        id2side_[id]  = is_buy;

        auto now = Clock::now();
        if (is_buy) matchBuySide(trades, now);
        else        matchSellSide(trades, now);
        return trades;
    }

    // For tests/metrics
    PriceType bestBid() const { return const_cast<OrderBook<PriceType, OrderIdType>&>(book_).bestBid(); }
    PriceType bestAsk() const { return const_cast<OrderBook<PriceType, OrderIdType>&>(book_).bestAsk(); }

private:
    // BUY takes from lowest ask upward while ask <= aggressive buy price.
    void matchBuySide(std::vector<TradeT>& out, const typename Clock::time_point& now) {
        while (true) {
            // Check top of book cross
            PriceType best_ask = book_.bestAsk();
            if (best_ask == PriceType{}) break; // no asks
            // Best bid implied by the incoming/top-of-queue buy (we'll check price condition below)

            // Find the earliest buy that can cross this ask
            auto b_it = bestExecutableBuy(best_ask);
            if (b_it == bids_.end()) break; // no buy that crosses

            auto& buy_q  = b_it->second;
            auto& sell_q = asks_[best_ask];
            if (sell_q.empty() || buy_q.empty()) {
                // Lazy clean-up if a level got stale
                if (sell_q.empty()) asks_.erase(best_ask);
                if (buy_q.empty())  bids_.erase(b_it);
                break;
            }

            OrderIdType buy_id  = buy_q.front();
            OrderIdType sell_id = sell_q.front();

            int buy_rem  = oms_.getRemainingQty(buy_id);
            int sell_rem = oms_.getRemainingQty(sell_id);
            // if (buy_rem <= 0) { popFrontAndPrune(bids_, b_it); continue; }
            if (buy_rem <= 0) {
                buy_q.pop_front();
                pruneLevelIfEmpty(bids_, b_it->first);
                continue;
            }

            if (sell_rem <= 0) { sell_q.pop_front(); pruneLevelIfEmpty(asks_, best_ask); continue; }

            const int exec = (buy_rem < sell_rem) ? buy_rem : sell_rem;

            // Execute at passive price (best_ask) â€“ typical limit order book rule
            out.push_back({buy_id, sell_id, best_ask, exec, now});

            // Apply fills in OMS; it updates remaining qty + state
            oms_.fill(buy_id, exec);
            oms_.fill(sell_id, exec);

            // Update aggregate book levels
            // We know exact orders and prices:
            book_.amendOrder(buy_id,  oms_.getRemainingQty(buy_id));
            book_.amendOrder(sell_id, oms_.getRemainingQty(sell_id));

            // Remove fully filled orders from queues and book aggregates
            if (oms_.getRemainingQty(buy_id) == 0) {
                buy_q.pop_front();
                pruneLevelIfEmpty(bids_, b_it->first);
                book_.deleteOrder(buy_id);
                id2price_.erase(buy_id);
                id2side_.erase(buy_id);
            }
            if (oms_.getRemainingQty(sell_id) == 0) {
                sell_q.pop_front();
                pruneLevelIfEmpty(asks_, best_ask);
                book_.deleteOrder(sell_id);
                id2price_.erase(sell_id);
                id2side_.erase(sell_id);
            }
        }
    }

    // SELL takes from highest bid downward while bid >= aggressive sell price.
    void matchSellSide(std::vector<TradeT>& out, const typename Clock::time_point& now) {
        while (true) {
            PriceType best_bid = book_.bestBid();
            if (best_bid == PriceType{}) break; // no bids

            // Find earliest sell that can cross this bid
            auto s_it = bestExecutableSell(best_bid);
            if (s_it == asks_.end()) break;

            auto& sell_q = s_it->second;
            auto& buy_q  = bids_[best_bid];
            if (sell_q.empty() || buy_q.empty()) {
                if (sell_q.empty()) asks_.erase(s_it);
                if (buy_q.empty())  bids_.erase(best_bid);
                break;
            }

            OrderIdType sell_id = sell_q.front();
            OrderIdType buy_id  = buy_q.front();

            int sell_rem = oms_.getRemainingQty(sell_id);
            int buy_rem  = oms_.getRemainingQty(buy_id);
            if (sell_rem <= 0) { sell_q.pop_front(); pruneLevelIfEmpty(asks_, s_it->first); continue; }
            if (buy_rem  <= 0) { buy_q.pop_front();  pruneLevelIfEmpty(bids_, best_bid);    continue; }

            const int exec = (sell_rem < buy_rem) ? sell_rem : buy_rem;

            // Execute at passive price (best_bid)
            out.push_back({buy_id, sell_id, best_bid, exec, now});

            oms_.fill(sell_id, exec);
            oms_.fill(buy_id,  exec);

            book_.amendOrder(sell_id, oms_.getRemainingQty(sell_id));
            book_.amendOrder(buy_id,  oms_.getRemainingQty(buy_id));

            if (oms_.getRemainingQty(sell_id) == 0) {
                sell_q.pop_front();
                pruneLevelIfEmpty(asks_, s_it->first);
                book_.deleteOrder(sell_id);
                id2price_.erase(sell_id);
                id2side_.erase(sell_id);
            }
            if (oms_.getRemainingQty(buy_id) == 0) {
                buy_q.pop_front();
                pruneLevelIfEmpty(bids_, best_bid);
                book_.deleteOrder(buy_id);
                id2price_.erase(buy_id);
                id2side_.erase(buy_id);
            }
        }
    }

    // Find the best buy level that crosses the given ask (buy price >= ask)
    typename std::map<PriceType, std::deque<OrderIdType>>::iterator
    bestExecutableBuy(PriceType ask_px) {
        // Highest buy price that is >= ask_px -> last element with key >= ask_px
        auto it = bids_.lower_bound(ask_px); // first key >= ask_px
        if (it == bids_.end()) return bids_.end();
        // We prefer highest price among those >= ask_px -> go to last element
        // Since map is ascending, we need the last element from [it, end).
        // But simpler: if there are higher prices, take the highest.
        auto best = bids_.end();
        for (auto jt = it; jt != bids_.end(); ++jt) best = jt;
        return best;
    }

    // Find the best sell level that crosses the given bid (sell price <= bid)
    typename std::map<PriceType, std::deque<OrderIdType>>::iterator
    bestExecutableSell(PriceType bid_px) {
        // Highest sell price that is <= bid_px -> last element strictly <= bid_px
        auto it = asks_.upper_bound(bid_px); // first key > bid_px
        if (it == asks_.begin()) return asks_.end();
        --it; // now it->first <= bid_px
        return it;
    }

    // Helpers to prune empty levels
    static void pruneLevelIfEmpty(std::map<PriceType, std::deque<OrderIdType>>& side, PriceType px) {
        auto it = side.find(px);
        if (it != side.end() && it->second.empty()) side.erase(it);
    }

    static void popFrontAndPrune(std::map<PriceType, std::deque<OrderIdType>>& side, PriceType px) {
        auto it = side.find(px);
        if (it == side.end()) return;
        if (!it->second.empty()) it->second.pop_front();
        if (it->second.empty()) side.erase(it);
    }

private:
    // Side books: price -> FIFO of order ids (price-time priority)
    std::map<PriceType, std::deque<OrderIdType>> bids_; // highest price wins
    std::map<PriceType, std::deque<OrderIdType>> asks_; // lowest price wins

    // Light lookups
    std::unordered_map<OrderIdType, PriceType> id2price_;
    std::unordered_map<OrderIdType, bool>      id2side_;

    // External subsystems
    OrderBook<PriceType, OrderIdType>& book_;
    OrderManager<PriceType, OrderIdType>& oms_;
};
